# kickfyne "fyne my way"

[The Fyne Toolkit](https://fyne.io/) is a favorite application tool kit of mine. After creating a couple of apps I decided to make my own little tool to build and manage building my fyne apps. So my tool is called kickfyne.

kickfyne only does 4 things

1. Creates it's application framework code in a folder with a go.mod file.
1. Adds to and removes from the framework GUI a little or a lot at a time.
1. Adds and removes messages and message handlers in the framework.
1. Adds and removes data records and their storage handlers in the framework.

All GO files generated by kickfyne, which require or allow edits, contain simple instructions at **KICKFYNE TODO** comments. A search of the source code for **KICKFYNE TODO**, anytime after running a **kickfyne** command, will reveal clear instructions about what can or must be done.

## Project summary

This is version 0.5.0. It's the changes I'm making while rewriting "One Key Piano". I'm finding that i want more freedom and less work.

* Complexities have been simplified.
* Bugs fixed.
* An issue I with widget.TabItem was overcome.
* Documentation improved.
* The application starts up much quicker.

## Framework summary

All of the application code is contained in  folders.

1. ./
1. ./frontend/
1. ./backend/
1. ./shared/

### The front-end's GUI has what you would expect in a fyne app

1. A system tray menu
1. An app menu.
1. A landing screen.
1. Any screens and panels a developer wants to add.

#### Screens

A screen is a package containing one or more panels and a messenger.

1. The panels are how the screen package interacts with the user, displaying content and accepting user input.
1. The messenger is how the screen package communicates with the back-end, sending and receiving messages.

A screen package is an important aspect of the front-end because it implements a single user action.

I'll describe allowing the user to select a contact and then edit it using 1 Screen with 2 Panels

1. The selectPanel:
   * Displays a select list with select button and a cancel button.
   * The cancel button returns the user back to the landing screen with the call **landingscreen.Land()**.
   * The select button passes the selection info in a call to the messenger.
   * The messenger sends the selection info to the back-end in a message.
   * When the back-end returns the message it contains the info for the user to edit. The messenger passes the info in a call to a editPanel func.
   * The editPanel displays the contact information in the edit form.
   * The messenger switches the user to the editPanel with the call **editPanel.show()**.
1. The editPanel:
   * Displays an edit form with an edit button and a cancel button.
   * The cancel button returns the user back to the selectPanel with the call **selectPanel.show()**.
   * The edit button passes the user input in a call to the messenger.
   * The messenger sends the user input info to the back-end in a message.
   * When the back-end returns the message it contains an error if there was one.
   * The messenger informs the user of the success or failure using fyne's dialog package.
   * The messenger switches the user back to the landing screen with the call **landingscreen.Land()**.

#### The landing screen

The application begins with the landing screen. Like any other screen, the landing screen operation needs to be developed and managed by the developer.

The app framework creates a **home** screen as the landing screen. The developer can use the home screen or add a new screen and then change the landing screen in the ./FyneApp.toml file. After the ./FyneApp.toml file is edited, the developer can update the app to the new screen and remove the home screen.

```shell
ï¼„ kickfyne screen update-landing
ï¼„ kickfyne screen remove home
```

ğŸ» INTRODUCING kickfyne!
kickfyne is a tool to help build an application using the fyne toolkit which has among other things a very nice GUI. The fyne toolkit web site is located at [fyne.io](https://fyne.io/). This kickfyne project is not in any way associated with this fyne toolkit project.

ğŸ—½ GETTING STARTED WITH kickfyne.

```shell
ï¼„ cd ~/projects/Â«name-of-my-appÂ»
ï¼„ go mod init "example.com/Â«name-of-my-appÂ»" or "github.com/Â«my-github-folderÂ»/Â«name-of-my-appÂ»"
ï¼„ kickfyne framework
```

ğŸš§ THE FRAMEWORK:
The framework is contained in 4 folders.

1. ./ which contains main.go and FyneApp.toml
1. ./backend/ which contains the back-end code.
1. ./frontend/ which contains the front-end code.
1. ./shared/ which contains shared code.

ğŸ”¨ BUILDING THE APP:
You can build the app after running the command "ï¼„ kickfyne framework".
The following build example is done in the app's folder.

```shell
ï¼„ go mod tidy
ï¼„ go build
ï¼„ ./Â«name-of-executableÂ»
```

ğŸ‘€ THE front-end:
The front-end's user interface is built with screen packages. A screen package is composed of panels and a messenger. The panels are how the screen package interacts with the user, displaying content and accepting user input. The messenger is how the screen package communicates with the back-end, sending and receiving messages.

For example a screen might have a panel where the user selects a record to edit and then another panel for editing the record. Meanwhile the messenger is communicating with the back-end getting records for selection, a record for editing, and sending the edited record to the back-end for storage and switching panels.

Alternately, the above screen with two panels could be done with two screens. One screen with only a select panel and the other screen with only an edit panel.

ğŸ“º MANAGING SCREENS:

```shell
ï¼„ kickfyne screen add Â«screen-package-nameÂ»
ï¼„ kickfyne screen add-accordion Â«screen-package-nameÂ»
ï¼„ kickfyne screen add-apptabs Â«screen-package-nameÂ»
ï¼„ kickfyne screen add-doctabs Â«screen-package-nameÂ»
ï¼„ kickfyne screen remove Â«screen-package-nameÂ»
ï¼„ kickfyne screen list
ï¼„ kickfyne screen update-landing
ï¼„ kickfyne screen help
```

After a screen is added:

1. The following success message is displayed. The file paths displayed, link to the files that were just added and need attention. A search for KICKFYNE TODO will reveal instructions for proper developement and management of the screen operation.

   ```shell
   ï¼„ kickfyne screen add-apptabs example
   Added the AppTabs screen package named "example".
   KICKFYNE TODO: The doc file at frontend/gui/screens/example/doc.go:1:1 may need some editing.
   KICKFYNE TODO: You may want to review func tabItems in the AppTabs panel file at frontend/gui/screens/example/apptabsPanel.go:1:1.
   ```


ğŸ“Š MANAGING SCREEN PANELS:

```shell
ï¼„ kickfyne panel add Â«screen-package-nameÂ» Â«panel-nameÂ»
ï¼„ kickfyne panel remove Â«screen-package-nameÂ» Â«panel-nameÂ»
ï¼„ kickfyne panel list Â«screen-package-nameÂ»
ï¼„ kickfyne panel help
```

After a panel is added:

1. The following success message is displayed. The file paths displayed, link to the files that were just added and need attention. A search for KICKFYNE TODO will reveal instructions for proper developement and management of the panel operation.

   ```shell
   ï¼„ kickfyne panel add example addtabPanel
   Success:
   Added the panel named "addtabPanel.go" to the screen package "example".
   KICKFYNE TODO: Edit the new panel file at frontend/gui/screens/example/addtabPanel.go:1:1.
   KICKFYNE TODO: The AppTabs panel file at frontend/gui/screens/example/apptabsPanel.go:1:1 may need some editing.
   ```

ğŸ’¬ MESSAGES:
The front-end and back-end are separate go threads that communicate using messages.

MANAGING MESSAGES:

```shell
ï¼„ kickfyne message add Â«message-nameÂ»
ï¼„ kickfyne message remove Â«message-nameÂ»
ï¼„ kickfyne message list
ï¼„ kickfyne message help
```

* Message definitions are at "shared/message/".
* The back-end message handlers are at "backend/txrx/"
* The front-end message handlers are in each screen's messageHandler.go file.
* A message name is upper camel case so a valid message name might be "AddContact".

After a message is added:

1. The following success message is displayed. The file paths displayed, link to the files that were just added and need attention. A search for KICKFYNE TODO will reveal instructions for proper developement and management of the message and handler operation.

   ```shell
   ï¼„ kickfyne message add SaveContact
   Success. Message named "SaveContact" added.
   KICKFYNE TODO: The message definition at shared/message/saveContact.go:1:1 may need some editing.
   KICKFYNE TODO: The back-end message handler at backend/txrx/saveContact.go:1:1 may need some editing.
   ```

1. Some front-end message handlers will need to handle sending and or receiving the message.

ğŸ’¾ RECORDS:

When a record is added, the record's store interface and implementation are also added.

MANAGING RECORDS AND STORES:

```shell
ï¼„ kickfyne record add Â«record-nameÂ»
ï¼„ kickfyne record remove Â«record-nameÂ»
ï¼„ kickfyne record list
ï¼„ kickfyne record help
```

* Record definitions are at shared/store/record/.
* Record store interfaces are at shared/store/storer/.
* Record store implementations are at shared/store/storing/.
* A record name is upper camel case so a valid record name might be "Contact".

After a record is added:

1. The following success message is displayed. The file paths displayed, link to the files that were just added and need attention. A search for KICKFYNE TODO will reveal instructions for proper developement and management of the record and store operation.

   ```shell
   ï¼„ kickfyne record add Contact
   Success. Record named "Contact" added.
   KICKFYNE TODO: The record definition at shared/store/record/contact.go:1:1 may need some editing.
   KICKFYNE TODO: The storer interface definition at shared/store/storer/contact.go:1:1 may need some editing.
   KICKFYNE TODO: The storer interface implementation at shared/store/storing/contact.go:1:1 may need some editing.
   ```

   1. The record's store interface and implementation may need modification. The records are by default, stored locally in easy to read yaml files. If that is not how the application is to handle data then modifications can be made to a record's store interface and implementation.
